--------------------------------------------------Multi-thread-----------------------------------------------------------
*************************************************************************************************************************
1.通过继承Thread来实现多线程，并重写run方法：
public class MyThread extends Thread {
	private int i = 0;
	@Override
	public void run() {
		for (; i < 100; i++) {
			System.out.println(getName() + " " + i);
		}
	}
	public static void main(String[] args) {
		for(int i = 0; i < 100; i++){
			System.out.println(Thread.currentThread().getName() + " " + i);
			if(i == 20){
				new MyThread().start();
				new MyThread().start();
			}
		}
	}
}
打印的结果，有三条线程同时执行，main线程和thread-0和thread-1，均会打印出从0-99的值。
每次启动新的线程在heap中创建了一个新的Mythread对象，每个Mythread对象都有私有的i属性，所以不会产生多线程安全问题。
源码：
	@Override
    public void run() {					//Thread源码中的run方法是调用了target的run方法，而target是一个callable对象，如果没有传入callable对象这个方法什么都不做，所以利用overide在子类中对该方法进行定义。
        if (target != null) {
            target.run();
        }
    }
	
	public synchronized void start() {												//Change the thread from NEW to Runable.
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)														//该线程对象是否处于NEW state。
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);															//每个线程对象都有一个私有的ThreadGroup对象，将当前线程加入线程组，线程组被初始化时nUnstartedThreads被设置，现在可以--

        boolean started = false;
        try {
            start0();				-->private native void start0();				//调用C或是C++来启动当前线程。
            started = true;
        } finally {
            try {
                if (!started) {														//如果start失败，即C语言失败，修改ThreadGroup中对应的参数。C中对应的线程如果启动失败一般都是Core dump，不知道如何捕捉异常，需要研究JVM。
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
	
*************************************************************************************************************************
2.实现Runnable接口来实现多线程：
package ca.mcmaster.multithread;
/**
 * @author SeanForFun E-mail:xiaob6@mcmaster.ca
 * @date Apr 7, 2018 6:43:41 PM
 * @version 1.0
 */
public class MyRunnable implements Runnable {

	private int i = 0;
	public void print(){
		System.out.println(Thread.currentThread().getName() + " " + i);
	}
	@Override
	public void run() {															//重写run()方法，将线程的业务写在run方法中
		for(; i < 100; i++){
			print();
		}
	}
	
	public static void main(String[] args) {
		MyRunnable myRunnable = new MyRunnable();
		for(int i = 0; i < 100; i++){
			System.out.println(Thread.currentThread() + " " + i);
			if(i == 20){
				new Thread(myRunnable, "thread-0").start();						//将我们的callable实现类传入Thread中，在run()方法中会调用Runable的方法
				new Thread(myRunnable, "thread-1").start();
				new Thread(myRunnable, "thread-2").start();
				new Thread(myRunnable, "thread-3").start();
			}
		}
	}
}
打印结果：
	thread-1 90
	thread-3 89
	Thread[main,5,main] 57
	thread-3 95
	1.首先发现i作为runnable对象是共享的，会造成线程安全问题。但是因为++操作是原子性的，所以不会出现读写问题。
	2.不是按顺序打印的，说明了对打印资源的获取出现了问题，此时打印资源被认为是一种临界资源（critical resource）。
	解决方案：
		synchronized public void print(){
			System.out.println(Thread.currentThread().getName() + " " + i);
		}
		这是一种较为慢的加锁方式，synchronized的具体细节将会在下文讨论。

总结：
	该方法的实质和继承Thread方法没有区别，但是是实现接口而不是继承类，设计上更加清洁。
	
*************************************************************************************************************************
3.实现Callable接口实现多线程：
	package ca.mcmaster.multithread;

	import java.util.concurrent.Callable;
	import java.util.concurrent.FutureTask;

	/**
	 * @author SeanForFun E-mail:xiaob6@mcmaster.ca
	 * @date Apr 7, 2018 7:29:10 PM
	 * @version 1.0
	 */
	public class MyCallable implements Callable<Integer> {
		@Override
		public Integer call() throws Exception {
			int i = 0;
			for (i = 0; i < 100; i++) {
				System.out.println(Thread.currentThread().getName() + " " + i);
			}
			return i;
		}
		
		public static void main(String[] args) {
			MyCallable myCallable = new MyCallable();
			FutureTask<Integer> futureTask = new FutureTask<>(myCallable);					//一个FutureTask只能接受一个Callable对象（已经验证），不然会造成返回值的同步问题（个人猜测）。
			for(int i = 0; i < 100; i ++){
				System.out.println(Thread.currentThread().getName() + " " + i);
				if(i == 20){
					new Thread(futureTask, "callable-0").start();
				}
			}
			try {
				System.out.println("Value returned from thread: " + futureTask.get());		//通过get方法获取线程的返回值。
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	源码：
	public FutureTask(Callable<V> callable) {									
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;														//一个FutureTask只能接受一个Callable对象
        this.state = NEW;       // ensure visibility of callable
    }
	public void run() {																	//Thread对象调用run()方法
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;
            if (c != null && state == NEW) {
                V result;
                boolean ran;															//调用call()方法。
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);														//将局部变量result更新到线程的属性outcome。
            }																			//private Object outcome;  non-volatile, protected by state reads/writes
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }
总结：
	1.该方法也是通过实现接口实现多线程。相对清洁。
	2.实际上是利用了FutureTask类的对象。每个FutureTask对象会接收一个Callable的实现对象，不能接收多个！
	3.实际上是和Runnable方法的实现方式一致，因为FutureTask是Runnable接口的子类。
	
--------------------------------------------------Lifecycle--------------------------------------------------------------
Five States in life cycle:
	新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)

1. 新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值
	Thread t = new Thread();
	此时在堆中有一个Thread的实现对象，所有空间和资源已经准备就绪。
2. 就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行
	程序计数器program counter:
	微机原理中学习的知识，用于存储下一条汇编的地址。
	方法栈：
	每个函数都会在内存中开辟一块空间，并且初始化函数栈中的参数。
3. 运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态
	执行线程所需要的业务，占用CPU资源。
4. 阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态
	① 线程调用sleep()方法主动放弃所占用的处理器资源
	② 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞
	③ 线程试图获得一个同步监视器(synchronized)，但该同步监视器正被其他线程所持有。这种方法以最大的代价维护了线程安全。
	④ 线程在等待某个通知（notify）	//public final native void notify();
	⑤ 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法
5. 死亡状态：
	① run()或call()方法执行完成，线程正常结束。
	② 线程抛出一个未捕获的Exception或Error。
	③ 直接调用该线程stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。

总结：线程的生命周期看上去抽象切不好理解，却是代码实现的重要依据，在多线程编程时需要深刻理解每个线程在某一时间的生命周期状态从而实现线程安全和业务功能。

--------------------------------------------------ThreadControl--------------------------------------------------------------
1.join:Thread提供了让一个线程等待另一个线程完成的方法join()方法。当在某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被join()方法加入的join线程执行完为止。join()方法通常由使用线程的程序调用，以将大问题划分成许多小问题，每个小问题分配一个线程。当所有的小问题都得到处理后，再调用主线程来进一步操作。
	public static void main(String[] args) throws Exception {
      // 启动子线程
      new JoinThread("新线程").start();
      for (int i = 0; i < 100; i++) {
         if (i == 20) {
            JoinThread jt = new JoinThread("被Join的线程");
            jt.start();
            // main线程调用了jt线程的join()方法，main线程
            // 必须等jt执行结束才会向下执行
            jt.join();
         }
         System.out.println(Thread.currentThread().getName() + "" + i);
      }
   }
2.setDeamon:设置为守护线程：
    public class DaemonThread extends Thread {
       // 定义后台线程的线程执行体与普通线程没有任何区别
       public void run() {
          for (int i = 0; i < 1000; i++) {
             System.out.println(getName() + "" + i);
          }
       }
     
       public static void main(String[] args) {
          DaemonThread t = new DaemonThread();
          // 将此线程设置成后台线程
          t.setDaemon(true);
          // 启动后台线程
          t.start();
          for (int i = 0; i < 10; i++) {
             System.out.println(Thread.currentThread().getName() + "" + i);
          }
          // -----程序执行到此处，前台线程（main线程）结束------
          // 后台线程也应该随之结束
       }
    }
3.sleep:让该线程进入睡眠，同时也交出了cpu的使用权：	
    public class SleepTest {
        public static void main(String[] args) throws Exception {
            for (int i = 0; i < 10; i++) {
                System.out.println("当前时间: " + new Date());
                // 调用sleep方法让当前线程暂停1s。
                Thread.sleep(1000);
            }
        }
    }
	
4.yield:它也是Threard类提供的一个静态方法，它也可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入就绪状态。yield()只是让当前线程暂停一下，让系统的线程调度器重新调度一次，完全可能的情况是：当某个线程调用了yield()方法暂停之后，线程调度器又将其调度出来重新执行。
	总结就是暂时交出CPU的占用，进入Runnale态。	
    public class YieldTest extends Thread {
       public YieldTest(String name) {
          super(name);
       }
     
       // 定义run方法作为线程执行体
       public void run() {
          for (int i = 0; i < 50; i++) {
             System.out.println(getName() + "" + i);
             // 当i等于20时，使用yield方法让当前线程让步
             if (i == 20) {
                Thread.yield();
             }
          }
       }
     
       public static void main(String[] args) throws Exception {
          // 启动两条并发线程
          YieldTest yt1 = new YieldTest("高级");
          // 将ty1线程设置成最高优先级
          // yt1.setPriority(Thread.MAX_PRIORITY);
          yt1.start();
          YieldTest yt2 = new YieldTest("低级");
          // 将yt2线程设置成最低优先级
          // yt2.setPriority(Thread.MIN_PRIORITY);
          yt2.start();
       }
    }

--------------------------------------------------Lock-----------------------------------------------------------------------
公平锁：指多个线程按照申请锁的顺序来获取锁。	
非公平锁：指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

可重入锁 ReentrantLock：可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。对于Java ReentrantLock而言, 其名字是Re entrant Lock即是重新进入锁。对于synchronized而言，也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。
其中，synchronized和ReentrantLock均是可重入锁。
理解：可重入锁指的是

独享锁 Exclusive lock：指该锁一次只能被一个线程所持有。
共享锁 shared lock：指该锁可被多个线程所持有。

乐观锁/悲观锁
乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语synchronized关键字的实现就是悲观锁。
乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。	
分段锁 SegmentLock：
强烈建议阅读源码！很有趣！
分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。当需要put元素的时候，并不是对整个HashMap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取HashMap全局信息的时候，就需要获取所有的分段锁才能统计。
自旋锁 SpinLock:
在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU

偏向锁/轻量级锁/重量级锁
这三种锁是指锁的状态，并且是针对synchronized。在Java 5通过引入锁升级的机制来实现高效synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

---------------------------------------------------AQS-----------------------------------------------------------------------
1.AbstractQueuedSynchronized:抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架
java.util.concurrent.locks.AbstractQueuedSynchronizer
	         *      +------+  prev +-----+       +-----+
  resource   * head |      | <---- |     | <---- |     |  tail
             *      +------+       +-----+       +-----+
	volatile resource;		//volatile是一个给JVM的提示i，告知JVM该资源非常抢手，尽快更新（写回内存）
	所有的线程被排在一个FIFO队列中，按序获取资源。

---------------------------------------------------CAS-----------------------------------------------------------------------


---------------------------------------------------Synchronized--------------------------------------------------------------
1.首先可以确认，synchronized是可重入锁，在get中调用了set，而此时的get并没有解锁而set又需要获取锁，同事发现set执行了，说明在同一个代码块中，内部的代码会自动获取synchronized锁，我们称之为可重入锁。
public class RtLock implements Runnable {
	private int i = 0;
	private void set(){
		for(int j = 0; j < 20; j++)
			System.out.println(Thread.currentThread() + " " + i++);
	}
	public synchronized void get(){
		System.out.println(Thread.currentThread() + " get");
		set();
	}
	@Override
	public synchronized void run() {
		get();
	}
	
	public static void main(String[] args) {
		RtLock rtLock = new RtLock();
		for(int i = 0; i < 2; i++){
			new Thread(rtLock, "thread-"+i).start();
		}
	}
}
结果：
	Thread[thread-0,5,main] get
	Thread[thread-0,5,main] 0
	Thread[thread-0,5,main] 1
	Thread[thread-1,5,main] get
	Thread[thread-1,5,main] 2
	Thread[thread-1,5,main] 3

2.对于内部的set方法是否也需要上锁的问题:
	public class RtLock implements Runnable {
		private int i = 0;
		private void set(){
			for(int j = 0; j < 10; j++)
				System.out.println(Thread.currentThread() + " " + i++);
		}
		public synchronized void get(){
			System.out.println(Thread.currentThread() + " get");
			set();
		}
		@Override
		public synchronized void run() {
			get();
		}
		
		public static void main(String[] args) {
			RtLock rtLock = new RtLock();
			for(int i = 0; i < 2; i++){
				new Thread(rtLock, "thread-"+i).start();
			}
			for(int j = 0; j < 10; j++)
				rtLock.set();
		}
	}
	结果：
		Thread[thread-0,5,main] get
		Thread[thread-0,5,main] 1
		Thread[main,5,main] 0
		Thread[thread-0,5,main] 2
		Thread[main,5,main] 3
		Thread[thread-0,5,main] 4
		乱序，因为main方法也在抢占set的资源。

	如果每个线程都跑一样的业务的话，内部方法是可以不需要上锁的，如果不同的业务交织在一起，在需要对所有的临界资源（critical source）上锁。

***总结：事实上synchronized方法是在告诉JVM，不要再将资源放在缓存中了！每次直接更新到内存中。
		这是一种重量级的锁，每次都会导致获取不到资源的线程挂起，而挂起和恢复的过程都是用户态和内核态的切换，十分占用系统资源。
---------------------------------------------------ReentrantLock-------------------------------------------------------------


---------------------------------------------------SpinLock------------------------------------------------------------------


---------------------------------------------------Pass Values to thread-----------------------------------------------------
*************************************************Constructor*****************************************************************

*************************************************Use variables and methods***************************************************

*************************************************Use Callback functions******************************************************

----------------------------------------------------ThreadLocal--------------------------------------------------------------

----------------------------------------------------Wait/Notify--------------------------------------------------------------

----------------------------------------------------Affinity-----------------------------------------------------------------

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
