--------------------------------------------------Multi-thread and Lock--------------------------------------------------
*************************************************************************************************************************
1.通过继承Thread来实现多线程，并重写run方法：
public class MyThread extends Thread {
	private int i = 0;
	@Override
	public void run() {
		for (; i < 100; i++) {
			System.out.println(getName() + " " + i);
		}
	}
	public static void main(String[] args) {
		for(int i = 0; i < 100; i++){
			System.out.println(Thread.currentThread().getName() + " " + i);
			if(i == 20){
				new MyThread().start();
				new MyThread().start();
			}
		}
	}
}
打印的结果，有三条线程同时执行，main线程和thread-0和thread-1，均会打印出从0-99的值。
每次启动新的线程在heap中创建了一个新的Mythread对象，每个Mythread对象都有私有的i属性，所以不会产生多线程安全问题。
源码：
	@Override
    public void run() {					//Thread源码中的run方法是调用了target的run方法，而target是一个callable对象，如果没有传入callable对象这个方法什么都不做，所以利用overide在子类中对该方法进行定义。
        if (target != null) {
            target.run();
        }
    }
	
	public synchronized void start() {												//Change the thread from NEW to Runable.
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)														//该线程对象是否处于NEW state。
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);															//每个线程对象都有一个私有的ThreadGroup对象，将当前线程加入线程组，线程组被初始化时nUnstartedThreads被设置，现在可以--

        boolean started = false;
        try {
            start0();				-->private native void start0();				//调用C或是C++来启动当前线程。
            started = true;
        } finally {
            try {
                if (!started) {														//如果start失败，即C语言失败，修改ThreadGroup中对应的参数。C中对应的线程如果启动失败一般都是Core dump，不知道如何捕捉异常，需要研究JVM。
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
	
*************************************************************************************************************************
2.实现Runnable接口来实现多线程：
package ca.mcmaster.multithread;
/**
 * @author SeanForFun E-mail:xiaob6@mcmaster.ca
 * @date Apr 7, 2018 6:43:41 PM
 * @version 1.0
 */
public class MyRunnable implements Runnable {

	private int i = 0;
	public void print(){
		System.out.println(Thread.currentThread().getName() + " " + i);
	}
	@Override
	public void run() {															//重写run()方法，将线程的业务写在run方法中
		for(; i < 100; i++){
			print();
		}
	}
	
	public static void main(String[] args) {
		MyRunnable myRunnable = new MyRunnable();
		for(int i = 0; i < 100; i++){
			System.out.println(Thread.currentThread() + " " + i);
			if(i == 20){
				new Thread(myRunnable, "thread-0").start();						//将我们的callable实现类传入Thread中，在run()方法中会调用Runable的方法
				new Thread(myRunnable, "thread-1").start();
				new Thread(myRunnable, "thread-2").start();
				new Thread(myRunnable, "thread-3").start();
			}
		}
	}
}
打印结果：
	thread-1 90
	thread-3 89
	Thread[main,5,main] 57
	thread-3 95
	1.首先发现i作为runnable对象是共享的，会造成线程安全问题。但是因为++操作是原子性的，所以不会出现读写问题。
	2.不是按顺序打印的，说明了对打印资源的获取出现了问题，此时打印资源被认为是一种临界资源（critical resource）。
	解决方案：
		synchronized public void print(){
			System.out.println(Thread.currentThread().getName() + " " + i);
		}
		这是一种较为慢的加锁方式，synchronized的具体细节将会在下文讨论。

总结：
	该方法的实质和继承Thread方法没有区别，但是是实现接口而不是继承类，设计上更加清洁。
	
*************************************************************************************************************************
3.实现Callable接口实现多线程：
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
