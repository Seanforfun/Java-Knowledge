--------------------------------------------------Multi-thread-----------------------------------------------------------
*************************************************************************************************************************
1.通过继承Thread来实现多线程，并重写run方法：
public class MyThread extends Thread {
	private int i = 0;
	@Override
	public void run() {
		for (; i < 100; i++) {
			System.out.println(getName() + " " + i);
		}
	}
	public static void main(String[] args) {
		for(int i = 0; i < 100; i++){
			System.out.println(Thread.currentThread().getName() + " " + i);
			if(i == 20){
				new MyThread().start();
				new MyThread().start();
			}
		}
	}
}
打印的结果，有三条线程同时执行，main线程和thread-0和thread-1，均会打印出从0-99的值。
每次启动新的线程在heap中创建了一个新的Mythread对象，每个Mythread对象都有私有的i属性，所以不会产生多线程安全问题。
源码：
	@Override
    public void run() {					//Thread源码中的run方法是调用了target的run方法，而target是一个callable对象，如果没有传入callable对象这个方法什么都不做，所以利用overide在子类中对该方法进行定义。
        if (target != null) {
            target.run();
        }
    }
	
	public synchronized void start() {												//Change the thread from NEW to Runable.
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)														//该线程对象是否处于NEW state。
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);															//每个线程对象都有一个私有的ThreadGroup对象，将当前线程加入线程组，线程组被初始化时nUnstartedThreads被设置，现在可以--

        boolean started = false;
        try {
            start0();				-->private native void start0();				//调用C或是C++来启动当前线程。
            started = true;
        } finally {
            try {
                if (!started) {														//如果start失败，即C语言失败，修改ThreadGroup中对应的参数。C中对应的线程如果启动失败一般都是Core dump，不知道如何捕捉异常，需要研究JVM。
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
	
*************************************************************************************************************************
2.实现Runnable接口来实现多线程：
package ca.mcmaster.multithread;
/**
 * @author SeanForFun E-mail:xiaob6@mcmaster.ca
 * @date Apr 7, 2018 6:43:41 PM
 * @version 1.0
 */
public class MyRunnable implements Runnable {

	private int i = 0;
	public void print(){
		System.out.println(Thread.currentThread().getName() + " " + i);
	}
	@Override
	public void run() {															//重写run()方法，将线程的业务写在run方法中
		for(; i < 100; i++){
			print();
		}
	}
	
	public static void main(String[] args) {
		MyRunnable myRunnable = new MyRunnable();
		for(int i = 0; i < 100; i++){
			System.out.println(Thread.currentThread() + " " + i);
			if(i == 20){
				new Thread(myRunnable, "thread-0").start();						//将我们的callable实现类传入Thread中，在run()方法中会调用Runable的方法
				new Thread(myRunnable, "thread-1").start();
				new Thread(myRunnable, "thread-2").start();
				new Thread(myRunnable, "thread-3").start();
			}
		}
	}
}
打印结果：
	thread-1 90
	thread-3 89
	Thread[main,5,main] 57
	thread-3 95
	1.首先发现i作为runnable对象是共享的，会造成线程安全问题。但是因为++操作是原子性的，所以不会出现读写问题。
	2.不是按顺序打印的，说明了对打印资源的获取出现了问题，此时打印资源被认为是一种临界资源（critical resource）。
	解决方案：
		synchronized public void print(){
			System.out.println(Thread.currentThread().getName() + " " + i);
		}
		这是一种较为慢的加锁方式，synchronized的具体细节将会在下文讨论。

总结：
	该方法的实质和继承Thread方法没有区别，但是是实现接口而不是继承类，设计上更加清洁。
	
*************************************************************************************************************************
3.实现Callable接口实现多线程：
	package ca.mcmaster.multithread;

	import java.util.concurrent.Callable;
	import java.util.concurrent.FutureTask;

	/**
	 * @author SeanForFun E-mail:xiaob6@mcmaster.ca
	 * @date Apr 7, 2018 7:29:10 PM
	 * @version 1.0
	 */
	public class MyCallable implements Callable<Integer> {
		@Override
		public Integer call() throws Exception {
			int i = 0;
			for (i = 0; i < 100; i++) {
				System.out.println(Thread.currentThread().getName() + " " + i);
			}
			return i;
		}
		
		public static void main(String[] args) {
			MyCallable myCallable = new MyCallable();
			FutureTask<Integer> futureTask = new FutureTask<>(myCallable);					//一个FutureTask只能接受一个Callable对象（已经验证），不然会造成返回值的同步问题（个人猜测）。
			for(int i = 0; i < 100; i ++){
				System.out.println(Thread.currentThread().getName() + " " + i);
				if(i == 20){
					new Thread(futureTask, "callable-0").start();
				}
			}
			try {
				System.out.println("Value returned from thread: " + futureTask.get());		//通过get方法获取线程的返回值。
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	源码：
	public FutureTask(Callable<V> callable) {									
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;														//一个FutureTask只能接受一个Callable对象
        this.state = NEW;       // ensure visibility of callable
    }
	public void run() {																	//Thread对象调用run()方法
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;
            if (c != null && state == NEW) {
                V result;
                boolean ran;															//调用call()方法。
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);														//将局部变量result更新到线程的属性outcome。
            }																			//private Object outcome;  non-volatile, protected by state reads/writes
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }
总结：
	1.该方法也是通过实现接口实现多线程。相对清洁。
	2.实际上是利用了FutureTask类的对象。每个FutureTask对象会接收一个Callable的实现对象，不能接收多个！
	3.实际上是和Runnable方法的实现方式一致，因为FutureTask是Runnable接口的子类。
	
--------------------------------------------------Lifecycle--------------------------------------------------------------
Five States in life cycle:
	新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)

1. 新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值
	Thread t = new Thread();
	此时在堆中有一个Thread的实现对象，所有空间和资源已经准备就绪。
2. 就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行
	程序计数器program counter:
	微机原理中学习的知识，用于存储下一条汇编的地址。
	方法栈：
	每个函数都会在内存中开辟一块空间，并且初始化函数栈中的参数。
3. 运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态
	执行线程所需要的业务，占用CPU资源。
4. 阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态
	① 线程调用sleep()方法主动放弃所占用的处理器资源
	② 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞
	③ 线程试图获得一个同步监视器(synchronized)，但该同步监视器正被其他线程所持有。这种方法以最大的代价维护了线程安全。
	④ 线程在等待某个通知（notify）	//public final native void notify();
	⑤ 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法
5. 死亡状态：
	① run()或call()方法执行完成，线程正常结束。
	② 线程抛出一个未捕获的Exception或Error。
	③ 直接调用该线程stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。

总结：线程的生命周期看上去抽象切不好理解，却是代码实现的重要依据，在多线程编程时需要深刻理解每个线程在某一时间的生命周期状态从而实现线程安全和业务功能。

--------------------------------------------------ThreadControl--------------------------------------------------------------
1.join:Thread提供了让一个线程等待另一个线程完成的方法join()方法。当在某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被join()方法加入的join线程执行完为止。join()方法通常由使用线程的程序调用，以将大问题划分成许多小问题，每个小问题分配一个线程。当所有的小问题都得到处理后，再调用主线程来进一步操作。
	public static void main(String[] args) throws Exception {
      // 启动子线程
      new JoinThread("新线程").start();
      for (int i = 0; i < 100; i++) {
         if (i == 20) {
            JoinThread jt = new JoinThread("被Join的线程");
            jt.start();
            // main线程调用了jt线程的join()方法，main线程
            // 必须等jt执行结束才会向下执行
            jt.join();
         }
         System.out.println(Thread.currentThread().getName() + "" + i);
      }
   }
2.setDeamon:设置为守护线程：
    public class DaemonThread extends Thread {
       // 定义后台线程的线程执行体与普通线程没有任何区别
       public void run() {
          for (int i = 0; i < 1000; i++) {
             System.out.println(getName() + "" + i);
          }
       }
     
       public static void main(String[] args) {
          DaemonThread t = new DaemonThread();
          // 将此线程设置成后台线程
          t.setDaemon(true);
          // 启动后台线程
          t.start();
          for (int i = 0; i < 10; i++) {
             System.out.println(Thread.currentThread().getName() + "" + i);
          }
          // -----程序执行到此处，前台线程（main线程）结束------
          // 后台线程也应该随之结束
       }
    }
3.sleep:让该线程进入睡眠，同时也交出了cpu的使用权：	
    public class SleepTest {
        public static void main(String[] args) throws Exception {
            for (int i = 0; i < 10; i++) {
                System.out.println("当前时间: " + new Date());
                // 调用sleep方法让当前线程暂停1s。
                Thread.sleep(1000);
            }
        }
    }
	
4.yield:它也是Threard类提供的一个静态方法，它也可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入就绪状态。yield()只是让当前线程暂停一下，让系统的线程调度器重新调度一次，完全可能的情况是：当某个线程调用了yield()方法暂停之后，线程调度器又将其调度出来重新执行。
	总结就是暂时交出CPU的占用，进入Runnale态。	
    public class YieldTest extends Thread {
       public YieldTest(String name) {
          super(name);
       }
     
       // 定义run方法作为线程执行体
       public void run() {
          for (int i = 0; i < 50; i++) {
             System.out.println(getName() + "" + i);
             // 当i等于20时，使用yield方法让当前线程让步
             if (i == 20) {
                Thread.yield();
             }
          }
       }
     
       public static void main(String[] args) throws Exception {
          // 启动两条并发线程
          YieldTest yt1 = new YieldTest("高级");
          // 将ty1线程设置成最高优先级
          // yt1.setPriority(Thread.MAX_PRIORITY);
          yt1.start();
          YieldTest yt2 = new YieldTest("低级");
          // 将yt2线程设置成最低优先级
          // yt2.setPriority(Thread.MIN_PRIORITY);
          yt2.start();
       }
    }


   
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
